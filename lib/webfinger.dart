// Copyright (c) 2015, Steven Roose. All rights reserved. Use of this source code
// is governed by a the license that can be found in the LICENSE file.

library webfinger;


import "dart:async";

import "package:http/http.dart";
import "package:webhand/webhand.dart";
import "package:xrd/xrd.dart";


class WebFinger {

  static const String _WEBFINGER_PATH = "/.well-known/webfinger";
  static const String _HOST_META_PATH = "/.well-known/host-meta";

  static const String _JRD_MIME = "application/jrd+json";
  static const String _XRD_MIME = "application/xrd+xml";

  // replace these with HttpHeaders and HttpStatus as they become available in package:http
  //  (https://github.com/dart-lang/http/issues/4)
  static const String _HTTP_HEADER_ACCEPT = "accept";
  static const String _HTTP_HEADER_CONTENT_TYPE = "Content-Type";
  static const int _HTTP_STATUS_OK = 200;


  final Client _client;

  const WebFinger(Client client) : _client = client;

  /**
   *`Retrieve the Web Host Metadata from the host of the [resource].
   *
   * If [preferHttps] is true, the method will try to use HTTPS first. Otherwise, the same scheme as used in the
   * provided resource will be used. HTTP fallback will be enabled unless [allowHttpFallback] is false.
   */
  Future<XrdDocument> hostMeta(dynamic/*Uri|String*/ resource, {bool preferHttps: true, bool allowHttpFallback: true}) {
    Uri resourceUri = resource is Uri ? resource : Uri.parse(resource);
    return _getXrd(new Uri(scheme: preferHttps ? "https" : resourceUri.scheme,
                           host: _extractHost(resourceUri),
                           path: _HOST_META_PATH), allowHttpFallback: allowHttpFallback);
  }

  /**
   * Perform a WebFinger query for the given [resource].
   *
   * The [resource] parameter should be either of type [Uri] or [String].
   *
   * If [rel] is provided, only those relations will be requested from the WebFinger provider. Depending on whether
   * or not the provider supports the parameter, only those relations will be in the resulting JRD document.
   *
   * If [noWebHand] is true, only the WebFinger endpoint defined in RFC 7033 will be requested.
   * Otherwise, the WebHand-compliant procedure will be used. For more info, visit www.webhand.org.
   *
   * To only get LRDDs from a specific origins, use the [webHandOrigins] parameter to specify the set of
   * origins you are interested in.
   *
   * The parameters [preferHttps] and [allowHttpFallback] are used to query the Web Host Metadata, see the documentation
   * of [hostMeta] for more details.
   */
  Future<XrdDocument> query(dynamic/*Uri|String*/ resource,
                            {List<String> rel,
                             bool noWebHand: false,
                             bool preferHttps: true,
                             bool allowHttpFallback: true,
                             List<String> webHandOrigins}) {
    if(resource is! Uri) resource = Uri.parse(resource);
    if(noWebHand == true) {
      return _getXrd(_webFingerUri(resource, rel), allowHttpFallback: false);
    } else {
      return _webHandQuery(resource,
                           preferHttps: preferHttps,
                           allowHttpFallback: allowHttpFallback,
                           webHandOrigins: webHandOrigins);
    }
  }

  Future<XrdDocument> _webHandQuery(Uri resource,
                                    {List<String> rel,
                                    bool preferHttps: true,
                                    bool allowHttpFallback: true,
                                    List<String> webHandOrigins}) {
    Completer completer = new Completer();
    // first query the WebFinger URI to check if it is generated by a WebHand-compliant WebFinger server
    // if it is, we complete with the result and all other LRDDs are ignored
    Future<XrdDocument> webFinger = _getXrd(_webFingerUri(resource, rel), allowHttpFallback: false).then((XrdDocument lrdd) {
      if(lrdd != null && WebHand.origin(lrdd) == "webhand") {
        completer.complete(lrdd);
      } else {
        return lrdd;
      }
    }, onError: (e) => null);
    // fetch the full list of LRDDs from host-meta
    List<Future<XrdDocument>> fingers = [webFinger];
    hostMeta(resource, preferHttps: preferHttps, allowHttpFallback: allowHttpFallback).then((XrdDocument meta) {
      if(completer.isCompleted)
        return null;
      // all LRDDs  to fetch
      List<XrdLink> lrdds = meta.allLinks("lrdd");
      // whether we already found the WebFinger LRDD so that we can put it in the right place
      bool fingerFound = false;
      String webFingerUri = _webFingerUri(resource).toString();
      for(XrdLink lrdd in lrdds) {
        String origin = WebHand.origin(lrdd);
        // we cannot perform WebHand checks if origin is not given
        // -> assume WebHand protocol is not supported
        if(origin != null) {
          // skip if we are not interested in the origin of the link
          if(webHandOrigins != null && !webHandOrigins.contains(origin)) {
            continue;
          }
          // ski[ if there is another link of the same origin with a preferred content type
          //   (we prefer JSON over XML as it is more compact)
          if(lrdd.type != _JRD_MIME && lrdds.any((l) => WebHand.origin(l) == origin && l.type == _JRD_MIME)) {
            continue;
          }
        }
        if(fingerFound == false && (origin == "webfinger" || lrdd.href == webFingerUri)) {
          fingerFound = true;
          fingers.add(fingers.removeAt(0));
          continue;
        }
        fingers.add(_getXrd(lrdd.resourceSpecificHref(resource), allowHttpFallback: false));
      }
      Future.wait(fingers).then((Iterable<XrdDocument> results) {
        completer.complete(WebHand.merge(results));
      });
    });
    return completer.future;
  }

  /**
   * Shortcut method for querying accounts of the "name@host" format.
   */
  Future<XrdDocument> account(String account,
                              {List<String> rel,
                              bool noWebHand: false,
                              bool preferHttps: true,
                              bool allowHttpFallback: true,
                              List<String> webHandOrigins}) {
    Uri address = Uri.parse(account);
    if(address.authority == "") {
      Uri addy = address.scheme == "" ? address.replace(scheme: "acct") : address;
      return query(addy, rel: rel, noWebHand: noWebHand, preferHttps: preferHttps,
                   allowHttpFallback: allowHttpFallback, webHandOrigins: webHandOrigins);
    }
    throw new ArgumentError("Please provide a valid account identifier.");
  }

  Future<XrdDocument> _getXrd(uri, {bool allowHttpFallback: false}) {
    if(uri is! Uri) uri = Uri.parse(uri);
    XrdDocument extractXrd(Response response) {
      String contentType = response.headers[_HTTP_HEADER_CONTENT_TYPE];
      if(contentType == _XRD_MIME) {
        return new XrdDocument.fromXml(response.body);
      } else if(contentType == _JRD_MIME) {
        return new XrdDocument.fromJson(response.body);
      } else {
        throw new FormatException("XRD document was of an unsupported content type: $contentType");
      }
    }
    Future fut = _client.get(uri)..catchError((e) {
      return _getXrd(uri.replace(scheme: "https"), allowHttpFallback: true);
    }, test: (e) => uri.scheme == "http" && allowHttpFallback);
    return fut.then((Response response) {
      if(response.statusCode == _HTTP_STATUS_OK) {
        return extractXrd(response);
      } else if(uri.scheme == "http" && allowHttpFallback) {
        return _getXrd(uri.replace(scheme: "https"), allowHttpFallback: true);
      } else {
        throw new StateError("HTTP error ${response.statusCode}: ${response.body}");
      }
    });
  }

  static Uri _webFingerUri(Uri resource, [List<String> rels]) {
    String queryBit = "resource=$resource";
    if(rels != null) {
      queryBit += "&";
      queryBit += rels.map((r) => "rel=${Uri.encodeQueryComponent(r)}").join("&");
    }
    return new Uri(scheme: "https", // "A client MUST query the WebFinger resource using HTTPS only.", RFC 7033
                   host: _extractHost(resource),
                   path: _WEBFINGER_PATH,
                   query: queryBit);
  }

  static String _extractHost(Uri uri) {
    if(uri.host != null && uri.host != "")
      return uri.host;
    // now we have an URI of the form "scheme:user@host"
    return uri.path.split("@").last;
  }

}